@using Alma.Modules.Workflows.Components.Registries
@using Alma.Modules.Workflows.Components.Shared
@using Alma.Workflows
@using Alma.Workflows.Core.Abstractions
@using Alma.Workflows.Core.InstanceExecutions.Entities
@using Alma.Workflows.Core.InstanceExecutions.Services
@using Alma.Workflows.Core.Instances.Services
@using Alma.Workflows.Definitions
@using Alma.Workflows.Enums
@using Alma.Workflows.Parsers
@using Alma.Workflows.Runners
@using Alma.Workflows.States
@using EnumsNET
@using Microsoft.Extensions.DependencyInjection

@inject NavigationManager NavigationManager
@inject IServiceScopeFactory ScopeFactory
@inject IDialogService DialogService
@inject ISnackbar Snackbar

@inject IFlowManager _flowManager;
@inject IInstanceManager _instanceManager;
@inject IInstanceExecutionManager _executionManager;
@inject IFlowDefinitionParser _definitionParser;
@inject IWorkflowRunnerFactory _runnerFactory;
@inject IParameterSetter _parameterSetter;

@inject IActivityComponentRegistry _activityComponentRegistry;

<MudStack Class="mud-width-full">
    @if (_isLoading || _runner is null)
    {
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    }
    else
    {
        <!-- Resumo -->
        <MudCard Elevation="0" Class="mud-background-gray rounded-lg">
            <MudCardContent>

                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText><b>@_InstanceName</b></MudText>
                    <InstanceExecutionStatusChip Status="Execution.Status" />
                </MudStack>

            </MudCardContent>
        </MudCard>

        <MudGrid>
            <!-- Atividade atual -->
            <MudItem xs="12" md="6" lg="8">
                <MudCard Elevation="8" Class="rounded-lg">
                    <MudCardContent>
                        <MudStack Spacing="0">
                            @{
                                if(_currentQueueItem is null)
                                {
                                    <MudText>Nenhuma atividade pendente de ser executada.</MudText>
                                }
                                else
                                {
                                    <MudText Class="mb-2"><b>@_currentQueueItem.Activity.DisplayName</b></MudText>

                                    <MudStack Row AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Outlined.PlayArrow" Class="mr-1 mud-text-secondary" Size="Size.Small" /> <span class="mud-text-secondary">@_currentQueueItem.ExecutionStatus.AsString(EnumFormat.Description)</span>
                                        @if (!string.IsNullOrEmpty(_currentQueueItem.ExecutionStatusReason))
                                        {
                                            <text>-</text><MudText Typo="Typo.body2" Color="Color.Error">@_currentQueueItem.ExecutionStatusReason</MudText>
                                        }
                                    </MudStack>

                                    <MudStack Row AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Outlined.HowToReg" Class="mr-1 mud-text-secondary" Size="Size.Small" /><span class="mud-text-secondary">@_currentQueueItem.ApprovalAndCheckStatus.AsString(EnumFormat.Description)</span>
                                    </MudStack>

                                    @if (_activityComponentRegistry.TryGetComponent(_currentQueueItem.Activity.Descriptor.Type, out var activityComponent))
                                    {
                                        <MudDivider Class="my-3" />

                                        <DynamicComponent @key="_currentQueueItem.Activity.Id"
                                        Type="activityComponent" 
                                        Parameters="@(new Dictionary<string, object> 
                                                    { 
                                                        ["Activity"] = _currentQueueItem.Activity,
                                                        ["ActivityExecutionContext"] = _runner.Context,
                                                        ["ActivityExecutionStatus"] = _currentQueueItem.ExecutionStatus,        
                                                        ["ActivityChanged"] = EventCallback.Factory.Create<IActivity>(this, HandleActivityChanged)
                                                    })" 
                                         />
                                    }
                                }
                            }
                        </MudStack>

                        <MudStack Row Justify="Justify.FlexEnd" Class="mt-3">
                            <MudButton OnClick="ExecuteCurrent" Disabled="IsExecutionDisabled()" Variant="Variant.Filled" Color="Color.Primary">Executar</MudButton>
                        </MudStack>
                    </MudCardContent>
                </MudCard>
            </MudItem>

            <!-- Próximas atividades -->
            <MudItem xs="12" md="6" lg="4">
                <ExecutionQueue Runner="_runner" CurrentQueueItemSequential="_currentQueueItem?.Sequential" OnQueueItemSelected="SetCurrentQueryItem" />
            </MudItem>

        </MudGrid>

    }

</MudStack>


@code {
    [Parameter]
    public InstanceExecution Execution { get; set; } = default!;

    #region private

    private bool _isLoading = true;

    private string _InstanceName = string.Empty;
    private string _versionName = string.Empty;

    private FlowDefinition _definition = default!;
    private WorkflowRunner _runner = default!;

    private QueueItem? _currentQueueItem;

    #endregion

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadSummary();
            await LoadRunner();

            await SetCurrentQueryItem();

            _isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadSummary()
    {
        using var scope = ScopeFactory.CreateScope();
        var instanceManager = scope.ServiceProvider.GetRequiredService<IInstanceManager>();

        _InstanceName = await instanceManager.GetName(Execution.InstanceId, Execution.Discriminator);
    }

    private async Task LoadRunner()
    {
        try
        {
            var definitionVersion = await _flowManager.FindDefinitionVersionById(Execution.DefinitionVersionId ?? string.Empty)
                ?? throw new Exception("Versão da definição não encontrada.");

            _definition = definitionVersion.FlowDefinition;
            var parsed = _definitionParser.TryParse(definitionVersion.FlowDefinition, out var flow);

            if (!parsed)
                throw new Exception("Erro ao tentar analisar a definição do fluxo de trabalho.");

            _runner = _runnerFactory.Create(flow, Execution.State, Execution.Options);
            await _runner.PreparePendingExecutionsAsync();
        }
        catch (Exception ex)
        {
            await ExecutionError(ex.Message);
        }
    }

    private async Task SetCurrentQueryItem(QueueItem? item = null)
    {
        if (item is null)
        {
            if (_runner.PendingExecutions.Count == 0)
            {
                _currentQueueItem = null;
                return;
            }

            var nextExecution = _runner.PendingExecutions.First();

            _currentQueueItem = nextExecution.QueueItem;
        }
        else
        {
            await _runner.PreparePendingExecutionsAsync(item.Id);
            _currentQueueItem = item;
        }
    }

    private async Task ExecuteCurrent()
    {
        await _runner.ExecuteNextAsync();
        await _executionManager.Update(Execution, _runner.Context.State);
        await SetCurrentQueryItem();
        StateHasChanged();
    }

    private async Task ExecutionError(string message)
    {
        await DialogService.ShowErrorDialog("Erro de execução", message);
    }

    private bool IsExecutionDisabled()
    {
        if (_currentQueueItem is null)
            return true;

        return !_currentQueueItem.CanExecute;
    }

    private async Task HandleActivityChanged(IActivity activity)
    {
        if (activity is null)
            return;

        var execution = _runner.PendingExecutions.FirstOrDefault(x => x.QueueItem.Activity.Id == activity.Id);
        if (execution is null)
            return;

        await _runner.CheckActivityStepStatus(execution);
    }
}
